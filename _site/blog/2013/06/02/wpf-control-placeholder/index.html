
<!DOCTYPE html>
<html lang="ZH-CN">
  <head>
    <meta charset="utf-8">
    <title>WPF控件开发(1)</title>
    <meta name="description" content="介绍WPF中做一个TextBox占位符的几种实现方法">
    <meta name="author" content="NanQi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/prettify.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/docs.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/">南琦的博客</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              
              
              


  
    
      
      	
      	<li>
            <a href="/archive.html">
                归档
                
                
            </a>
        </li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li>
            <a href="/categories.html">
                分类
                
                
            </a>
        </li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li>
            <a href="/MyProgram.html">
                我的软件
                
                
            </a>
        </li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li>
            <a href="/questions.html">
                问题
                
                
            </a>
        </li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li>
            <a href="/tags.html">
                标签
                
                
            </a>
        </li>
      	
      
    
  



            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="content">
        
<?xml version="1.0" encoding="utf-8"?>
<div class="page-header">
  <h1>WPF控件开发(1)
    <small>
      
      
          TextBox占位符
      
    </small>
  </h1>
</div>

<div class="row-fluid">
  <div class="span9">
    <div id="divPost">
      
      <p>在twitter-bootstrap中有这么一个功能：
<form class="form-horizontal"></p>

<div class="control-group">
    <label class="control-label" for="inputEmail">Email</label>
    <div class="controls">
      <input type="text" id="inputEmail" placeholder="Email">
    </div>
</div>


<p></form></p>

<p>我们如何在WPF也实现类似这种写法：</p>

<pre><code>&lt;TextBox local:placeholder="请输入筛选条件..." /&gt;
</code></pre>

<p>首先熟悉一点WPF的人都知道，placeholder在这里是一个附加属性，而这个附加属性的类型是String。</p>

<h2>第一种实现方式</h2>

<hr />

<p>首先我们想到的可能是这样：</p>

<pre><code>public static string GetPlaceholder1(DependencyObject obj)
{
    return (string)obj.GetValue(Placeholder1Property);
}

public static void SetPlaceholder1(DependencyObject obj, string value)
{
    obj.SetValue(Placeholder1Property, value);
}

public static readonly DependencyProperty Placeholder1Property =
    DependencyProperty.RegisterAttached("Placeholder1", typeof(string), typeof(TextBoxHelper),
        new UIPropertyMetadata(string.Empty, new PropertyChangedCallback(OnPlaceholder1Changed)));

public static void OnPlaceholder1Changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    TextBox txt = d as TextBox;
    if (txt == null || e.NewValue.ToString().Trim().Length == 0) return;

    RoutedEventHandler loadHandler = null;
    loadHandler = (s1, e1) =&gt;
    {
        txt.Loaded -= loadHandler;

        if (txt.Text.Length == 0)
        {
            txt.Text = e.NewValue.ToString();
            txt.FontStyle = FontStyles.Italic;
            txt.Foreground = Brushes.Gray;
        }
    };

    txt.Loaded += loadHandler;

    txt.GotFocus += (s1, e1) =&gt;
    {
        if (txt.Text == e.NewValue.ToString())
        {
            txt.Clear();
            txt.FontStyle = FontStyles.Normal;
            txt.Foreground = SystemColors.WindowTextBrush;
        }
    };

    txt.LostFocus += (s1, e1) =&gt;
    {
        if (txt.Text.Length == 0)
        {
            txt.Text = e.NewValue.ToString();
            txt.FontStyle = FontStyles.Italic;
            txt.Foreground = Brushes.Gray;
        }
    };
}
</code></pre>

<p>基本存在以下几个问题：</p>

<ul>
<li>获得焦点取消了占位符，与需求（twitter-bootstrap）不符，这里需要当输入内容以后才取消占位符；</li>
<li>如果这里某人恰巧也输入了”请输入筛选条件...”，当再次获得焦点的时候就会清空输入的内容，当然这一条完全可以再给一个标示去判断，比如在GotFocus的判断中，增加一个：</li>
</ul>


<pre>
txt.GotFocus += (s1, e1) =>
{
    if (txt.Text == e.NewValue.ToString()
     && txt.FontStyle == FontStyles.Italic
     && txt.Foreground == Brushes.Gray)
    {
        txt.Clear();
        txt.FontStyle = FontStyles.Normal;
        txt.Foreground = SystemColors.WindowTextBrush;
    }
};
</pre>


<ul>
<li>接之而来的问题就是如果TextBox恰巧需要设置FontStyle或Foreground，此时就无能为力；</li>
<li>其实最重要的问题还是，当我没有输入内容时，获取TextBox的Text属性，总有一个我不需要的值，或许加个判断可以搞定，但是这不是一个好的方式；</li>
</ul>


<h2>使用装饰器实现-1</h2>

<hr />

<p>上面实现方式所带来的弊端，可以使用装饰器解决。<br/>
首先定义一个装饰器，它可能是这样：</p>

<pre><code>public class PlaceholderAdorner1 : Adorner
{
    string _placeholder;

    public PlaceholderAdorner1(UIElement ele, string placeholder)
        : base(ele)
    {
        _placeholder = placeholder;
    }

    protected override void OnRender(DrawingContext drawingContext)
    {
        TextBox txt = this.AdornedElement as TextBox;
        if (txt == null || !txt.IsVisible || string.IsNullOrEmpty(_placeholder)) return;

        this.IsHitTestVisible = false;

        drawingContext.DrawText(
            new FormattedText
            (
                _placeholder, 
                CultureInfo.CurrentCulture,
                txt.FlowDirection,
                new Typeface(txt.FontFamily, FontStyles.Italic, txt.FontWeight, txt.FontStretch),
                txt.FontSize,
                Brushes.Gray
            ),
            new Point(4, 2));
    }
}
</code></pre>

<p>思路很简单，记录下这个占位符，然后给TextBox指定位置画出来。<br/>
这时候，附加属性可能是这样：</p>

<pre><code>public static string GetPlaceholder2(DependencyObject obj)
{
    return (string)obj.GetValue(Placeholder2Property);
}

public static void SetPlaceholder2(DependencyObject obj, string value)
{
    obj.SetValue(Placeholder2Property, value);
}

public static readonly DependencyProperty Placeholder2Property =
    DependencyProperty.RegisterAttached("Placeholder2", typeof(string), typeof(TextBoxHelper), 
        new UIPropertyMetadata(string.Empty, new PropertyChangedCallback(OnPlaceholder2Changed)));

public static void OnPlaceholder2Changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
{
    TextBox txt = d as TextBox;
    if (txt == null || e.NewValue.ToString().Trim().Length == 0) return;

    RoutedEventHandler loadHandler = null;
    loadHandler = (s1, e1) =&gt;
    {
        txt.Loaded -= loadHandler;

        var lay = AdornerLayer.GetAdornerLayer(txt);
        if (lay == null) return;

        Adorner[] ar = lay.GetAdorners(txt);
        if (ar != null)
        {
            for (int i = 0; i &lt; ar.Length; i++)
            {
                if (ar[i] is PlaceholderAdorner1)
                {
                    lay.Remove(ar[i]);
                }
            }
        }

        if (txt.Text.Length == 0)
            lay.Add(new PlaceholderAdorner1(txt, e.NewValue.ToString()));

    };
    txt.Loaded += loadHandler;
    txt.TextChanged += (s1, e1) =&gt;
    {
        bool isShow = txt.Text.Length == 0;

        var lay = AdornerLayer.GetAdornerLayer(txt);
        if (lay == null) return;

        if (isShow)
        {
            lay.Add(new PlaceholderAdorner1(txt, e.NewValue.ToString()));
        }
        else
        {
            Adorner[] ar = lay.GetAdorners(txt);
            if (ar != null)
            {
                for (int i = 0; i &lt; ar.Length; i++)
                {
                    if (ar[i] is PlaceholderAdorner1)
                    {
                        lay.Remove(ar[i]);
                    }
                }
            }
        }
    };
}
</code></pre>

<p>可以看到，附加属性只是对于装饰器的删除和添加，别无其他。<br/>
运行看看效果，都还不错，第一种实现所出现的问题也都能解决，但是随即发现一个问题：</p>

<ul>
<li>当隐藏（设置TextBox的Visibility为Hidden时），发现TextBox隐藏了，但是装饰器还存在。</li>
</ul>


<h2>使用装饰器实现-2</h2>

<hr />

<p>针对上述的问题，首先分析问题原因，首先知道OnRender方法是在UIElement中定义，看方法的注释中，意思似乎是只在布局改变时才调用，从OnRender方面下手几乎不可能。<br/>
回想WinForm出现此类情况的解决方案，无非是调用Invalidate之类的，但是存在一个时机的问题。<br/>
如果当TextBox的Visibility改变时，能获取通知，上述问题就可以解决，而且直接可以删除改装饰器。<br/>
鉴于WPF中的触发器能得到某个属性改变的通知，那么我们自己肯定也能得到。</p>

<pre><code>public PlaceholderAdorner1(UIElement ele, string placeholder)
    : base(ele)
{
    _placeholder = placeholder;

    var dpd = DependencyPropertyDescriptor.FromProperty(UIElement.VisibilityProperty, typeof(UIElement));
    dpd.AddValueChanged(ele, new EventHandler((s1, e1) =&gt;
    {
        this.InvalidateVisual();
    }));
}
</code></pre>

<p>测试发现，上述问题确实已经解决。<br/>
当然，除了可以在装饰器中重绘一次，还可以直接在属性改变时直接删除该装饰器。</p>

<pre><code>var dpd = DependencyPropertyDescriptor.FromProperty(UIElement.VisibilityProperty, typeof(UIElement));
dpd.AddValueChanged(txt, new EventHandler((s1, e1) =&gt;
{
    bool isShow = txt.Text.Length == 0 &amp;&amp; txt.Visibility == Visibility.Visible;

    var lay = AdornerLayer.GetAdornerLayer(txt);
    if (lay == null) return;

    if (isShow)
    {
        lay.Add(new PlaceholderAdorner1(txt, e.NewValue.ToString()));
    }
    else
    {
        Adorner[] ar = lay.GetAdorners(txt);
        if (ar != null)
        {
            for (int i = 0; i &lt; ar.Length; i++)
            {
                if (ar[i] is PlaceholderAdorner1)
                {
                    lay.Remove(ar[i]);
                }
            }
        }
    }
}));
</code></pre>

<p>这段代码当然直接可以写在OnPlaceholder2Changed事件处理函数中。</p>

<h2>装饰器的另一种实现方式</h2>

<hr />

<p>由于某次手动生成触发器的时候，发现注册属性改变通知和触发器还是有一定的不同的（具体问题有时间再提）。<br/>
所以对于这种实现方式总是心有余悸。<br/>
所幸装饰器除了使用OnRender方法，还有别的实现方式。</p>

<pre><code>public class PlaceholderAdorner2 : Adorner
{
    private VisualCollection _visCollec;
    private TextBlock _tb;
    private TextBox _txt;

    public PlaceholderAdorner2(UIElement ele, string placeholder)
        : base(ele)
    {
        _txt = ele as TextBox;
        if (_txt == null) return;

        Binding bd = new Binding("IsVisible");
        bd.Source = _txt;
        bd.Mode = BindingMode.OneWay;
        bd.Converter = new BoolToVisibilityConverter();
        this.SetBinding(TextBox.VisibilityProperty, bd);
        _visCollec = new VisualCollection(this);
        _tb = new TextBlock();
        _tb.Style = null;
        _tb.FontSize = _txt.FontSize;
        _tb.FontFamily = _txt.FontFamily;
        _tb.FontWeight = _txt.FontWeight;
        _tb.FontStretch = _txt.FontStretch;
        _tb.FontStyle = FontStyles.Italic;
        _tb.Foreground = Brushes.Gray;
        _tb.Text = placeholder;
        _tb.IsHitTestVisible = false;
        _visCollec.Add(_tb);
    }

    protected override int VisualChildrenCount
    {
        get
        {
            return _visCollec.Count;
        }
    }

    protected override Size ArrangeOverride(Size finalSize)
    {
        _tb.Arrange(new Rect(new Point(4, 2), finalSize));
        return finalSize;
    }

    protected override Visual GetVisualChild(int index)
    {
        return _visCollec[index];
    }
}
</code></pre>

<p>代码不难理解，就是给TextBox上面又放了一个TextBlock，并且把TextBlock的Visibility属性和TextBox的Visibility属性绑定。</p>

<p>end.</p>

      

    </div>
    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/blog/2013/05/04/Coder-of-Life" title="编程人生(1)">&larr; 上一页</a></li>
      
        <li><a href="/archive.html">列表</a></li>
      
        <li class="next"><a href="/blog/2013/06/16/wpf-control-autocomplete-1" title="WPF控件开发(2)">下一页 &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'nanqi'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




  </div>
  <div class="span3">
    <h4>Published</h4>
    <div class="date">
      <span>2013-06-02</span>
    </div>

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#C#-ref">C# <span>15</span></a></li>
     
    	<li><a href="/tags.html#WPF-ref">WPF <span>5</span></a></li>
    
  



    </ul>
  
  </div>
</div>


      </div>

      <footer>
        <p>&copy; NanQi 2012 - 2013
          参考 <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          和 <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
          源码托管在 <a href="https://github.com/nanqi">NanQi Github</a> 版权声明 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/">CC BY-NC-SA 3.0</a>
          <script src="http://s95.cnzz.com/stat.php?id=4758074&web_id=4758074" language="JavaScript"></script>
        </p>
      </footer>

    <script src="/assets/themes/twitter/js/jquery.js"></script>
    <script src="/assets/themes/twitter/js/prettify.js"></script>
    <script src="/assets/themes/twitter/js/holder.js"></script>
    <script src="/assets/themes/twitter/bootstrap/js/bootstrap.min.js"></script>
    </div> <!-- /container -->

    <script type="text/javascript">
        $(window).load(function () {
                $("pre").addClass("prettyprint linenums");
                prettyPrint();
        })
    </script>

    
  </body>
</html>

